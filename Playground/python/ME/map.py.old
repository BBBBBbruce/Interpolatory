import numpy as np
from imageio import imread, imwrite
import sys
import time
from plot_mv import plot_vector_field
from scipy.ndimage import convolve
import math

'''
Finds lowest ssd vector within a search region (can be used during initial search and expansion)
Returns best vector, lowest ssd, and ssd matrix for the block
'''
def search_region(block, image_pad, image_shape, r, c, size, vec_offset=(0,0)):
    ssds = np.zeros((2*size+1, 2*size+1))
    r_offset = r + size
    c_offset = c + size
    lowest_ssd = math.inf
    lowest_vec = vec_offset
    lowest_dist = math.inf
    for row in range(-size, size+1):
        for col in range(-size, size+1):
            ssd = math.inf
            if not ((row > 0 and r + row + block.shape[0] >= image_shape[0]) or (col > 0 and c + col + block.shape[1] >= image_shape[1]) or (r + row < 0) or (c + col < 0)):
                ssd = np.sum(np.abs(block - image_pad[r_offset + row : r_offset + row + block.shape[0], c_offset + col : c_offset + col + block.shape[1], :]))
            ssds[row, col] = ssd
            distance = (row * row) + (col * col)
            if ssd < lowest_ssd or (ssd == lowest_ssd and distance < lowest_dist):
                lowest_ssd = ssd
                lowest_vec = (row + vec_offset[0], col + vec_offset[1])
                lowest_dist = distance
    return lowest_vec, lowest_ssd, ssds

'''
Performs a full search block matching algorithm
Returns the block-wise vectors and ssd matrices
'''
def full_search_ssd(block_size, window_size, im1, im2):
    im1_pad = np.pad(im1, ((0, block_size), (0, block_size), (0, 0)))
    height = math.ceil(float(im1.shape[0])/float(block_size))
    width = math.ceil(float(im1.shape[1])/float(block_size))
    vectors = np.zeros((height, width, 2), dtype='float32')
    ssds = np.zeros((height, width, 2*window_size+1, 2*window_size+1), dtype='float32')
    im2_pad = np.pad(im2, ((window_size, block_size + window_size), (window_size, block_size + window_size), (0,0)))
    for row in range(0, height):
        for col in range(0, width):
            block = im1_pad[row*block_size : (row+1)*block_size, col*block_size : (col+1)*block_size, :]
            vec, _, ssd = search_region(block, im2_pad, im2.shape, row*block_size, col*block_size, window_size)
            vectors[row, col, :] = vec[:]
            ssds[row, col, :, :] = ssd[:, :]
    return vectors, ssds

def get_motion_vectors(block_size, region, sub_region, steps, min_block_size, im1, im2, map=True):
    weightings = np.array([
        [0.0625, 0.125, 0.0625],
        [0.125, 0.25, 0.125],
        [0.0625, 0.125, 0.0625]
    ])
    weightings = weightings[:,:,None]

    im1_lst = []
    im2_lst = []
    im1_lst.append(im1)
    im2_lst.append(im2)
    for i in range(1, steps+1):
        print('Downscaling level',i)
        im1_lst.append(convolve(im1_lst[-1] / 255.0, weightings, mode='constant')[::2, ::2] * 255.0)
        im2_lst.append(convolve(im2_lst[-1] / 255.0, weightings, mode='constant')[::2, ::2] * 255.0)
    
    print('Calculating initial motion vectors')
    mvs, ssd = full_search_ssd(block_size, region, im1_lst[-1], im2_lst[-1])

    if map:
        print('Applying MAP optimisations')
        # TODO: apply map optimisations

    for s in range(steps - 1, -1, -1):
        print('Propagating back to level', s)
        next_mvs = np.zeros((mvs.shape[0]*2, mvs.shape[1]*2, 3), dtype='float32')
        im2_pad = np.pad(im2_lst[s], ((region, block_size + region), (region, block_size + region), (0,0)))
        for row in range(mvs.shape[0]):
            for col in range(mvs.shape[1]):
                vecs = []
                vecs.append(mvs[row, col] * 2)  # parent vector (multiplied by 2 bc of image upscale)
                if col >= 1:
                    vecs.append(mvs[row, col - 1] * 2) 
                else:
                    vecs.append(mvs[row, col + 1] * 2)
                if row >= 1:
                    vecs.append(mvs[row - 1, col] * 2)
                else:
                    vecs.append(mvs[row + 1, col] * 2)
                for i in range(row * 2, (row + 1) * 2):
                    for j in range(col * 2, (col + 1) * 2):
                        block = im1_lst[s][i*block_size : (i+1)*block_size, j*block_size : (j+1)*block_size, :]
                        lowest_ssd = math.inf
                        lowest_vec = vecs[0][:2]
                        for vec in vecs:
                            new_i = i * block_size + int(vec[0])
                            new_j = j * block_size + int(vec[1])
                            v, ssd, _ = search_region(block, im2_pad, im2_lst[s].shape, new_i, new_j, sub_region, vec)
                            ssd = 0
                            if ssd < lowest_ssd:
                                lowest_ssd = ssd
                        next_mvs[i, j, :2] = lowest_vec[:]
                        next_mvs[i, j, 2] = lowest_ssd
        mvs = next_mvs

        
    im2_pad = np.pad(im2, ((region, block_size + region), (region, block_size + region), (0,0)))

    while(block_size > min_block_size):
        block_size = block_size >> 1
        print('Increasing density with block size', block_size)
        next_mvs = np.zeros((mvs.shape[0]*2, mvs.shape[1]*2, 3), dtype='float32')
        for row in range(mvs.shape[0]):
            for col in range(mvs.shape[1]):
                vecs = []
                vecs.append(mvs[row, col])  # parent vector
                if col >= 1:
                    vecs.append(mvs[row, col - 1]) 
                else:
                    vecs.append(mvs[row, col + 1])
                if row >= 1:
                    vecs.append(mvs[row - 1, col])
                else:
                    vecs.append(mvs[row + 1, col])
                for i in range(row*2, row*2+2):
                    for j in range(col*2, col*2+2):
                        block = im1[i*block_size : (i+1)*block_size, j*block_size : (j+1)*block_size, :]
                        lowest_ssd = math.inf
                        lowest_vec = vecs[0][:2]
                        for vec in vecs:
                            new_i = i * block_size + int(vec[0])
                            new_j = j * block_size + int(vec[1])
                            v, ssd, _ = search_region(block, im2_pad, im2.shape, new_i, new_j, sub_region, vec)
                            if ssd < lowest_ssd:
                                lowest_ssd = ssd
                                lowest_vec[:] = vec[:2]
                                lowest_vec[:] = v[:2]
                        next_mvs[i, j, :2] = lowest_vec[:]
                        next_mvs[i, j, 2] = lowest_ssd
        mvs = next_mvs

    print('Creating output')
    out = np.zeros_like(im1, dtype='float32')
    for row in range(mvs.shape[0]):
        for col in range(mvs.shape[1]):
            out[row * block_size : (row + 1) * block_size, col * block_size : (col + 1) * block_size, :] = mvs[row,col,:]

    return out


if __name__ == "__main__":
    block_size = int(sys.argv[1])
    region = int(sys.argv[2])
    sub_region = int(sys.argv[3])
    steps = int(sys.argv[4])
    min_block_size = int(sys.argv[5])
    im1 = imread(sys.argv[6])[:,:,:3]
    im2 = imread(sys.argv[7])[:,:,:3]
    out_path = sys.argv[8]
    output = get_motion_vectors(block_size, region, sub_region, steps, min_block_size, im1, im2, map=False)

    print('Printing output...')
    plot_vector_field(output, im1, 4, out_path)